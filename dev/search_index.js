var documenterSearchIndex = {"docs":
[{"location":"#CFDomains","page":"Home","title":"CFDomains","text":"Documentation for CFDomains.\n\n","category":"section"},{"location":"#General","page":"Home","title":"General","text":"","category":"section"},{"location":"#Vertical-interpolation","page":"Home","title":"Vertical interpolation","text":"","category":"section"},{"location":"#Operators-on-Voronoi-mesh","page":"Home","title":"Operators on Voronoi mesh","text":"","category":"section"},{"location":"#Virtual-zero-filled-arrays","page":"Home","title":"Virtual zero-filled arrays","text":"","category":"section"},{"location":"#CFDomains.AbstractDomain","page":"Home","title":"CFDomains.AbstractDomain","text":"Parent type of SpectralDomain and FDDomain\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.FDDomain","page":"Home","title":"CFDomains.FDDomain","text":"FDDomain <: AbstractDomain`\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.HVLayout","page":"Home","title":"CFDomains.HVLayout","text":"struct HVLayout{rank} end\nlayout = HVLayout(rank)\n\nSingleton type describing a multi-layer data layout where horizontal layers are contiguous in memory. rank is the number of horizontal indices (1 or 2).\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.HyperDiffusion-Union{Tuple{F}, Tuple{D}, Tuple{D, Any, F, Any}} where {D, F}","page":"Home","title":"CFDomains.HyperDiffusion","text":"filter = HyperDiffusion(fieldtype::Symbol, domain, niter::Int, nu)                  # user-friendly\nfilter = HyperDiffusion{fieldtype, D, F, X}(domain::D, niter::Int, nu::F, extra::X) # internal\n\nReturn a filter that applies Laplacian diffusion iterated niter times with hyperdiffusive coefficient nu ≥ 0 on fields of type fieldtype. Supported field types are :scalar, :vector, :vector_curl, :vector_div.\n\nThe filter is to be used as:\n\n# out-of-place, allocates `scratch`, allocates and returns `filtered_data`\nfiltered_data = filter(void, in_data, void)\n\n# mutating, non-allocating\nout_data = filter(out_data, in_data, scratch)\n\n# in-place, non-allocating\ninout_data = filter(inout_data, inout_data, scratch)\n\nfilter(out_data, in_data, scratch) returns hyperdiffusion!(filter.domain, filter, out_data, in_data, scratch). If scratch::Void, then\n\nscratch = scratch_space(filter, in_data)\n\nThe user-friendly HyperDiffusion may be specialized for specific types of domain. The specialized method should call the internal constructor which takes an extra argument extra, stored as filter.extra for later use by hyperdiffusion!. The default user-friendly constructor sets extra=nothing.\n\nSimilarly, scratch_space(filter, in_data) calls scratch_hyperdiff(f.domain, Val(fieldtype), in_data) which by default returns nothing. scratch_hyperdiff may be specialized for specific domain types and fieldtype.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.MassCoordinate","page":"Home","title":"CFDomains.MassCoordinate","text":"abstract type MassCoordinate{N} <: VerticalCoordinate{N} end\n\nParent type for a mass-based vertical coordinate. Children types should specialize mass_level. See also VerticalCoordinate and mass_coordinate.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.PressureCoordinate","page":"Home","title":"CFDomains.PressureCoordinate","text":"abstract type PressureCoordinate{N} <: VerticalCoordinate{N} end\n\nParent type for a pressure-based vertical coordinate. Children types should specialize pressure_level and mass_level. See also VerticalCoordinate.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.Shell","page":"Home","title":"CFDomains.Shell","text":"multi_layer_domain = Shell(nz::Int, layer::AbstractDomain, layout)\n\nReturn a multi-layer domain made of nz layers with data layout specified by layout. Unless you know what you are doing, it is recommended to use rather:\n\nmulti_layer_domain = shell(nz::Int, layer::AbstractDomain)\n\nwhich gets the data layout from data_layout(layer). Otherwise, multi_layer_domain may be non-optimal or non-usable.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.SigmaCoordinate","page":"Home","title":"CFDomains.SigmaCoordinate","text":"sigma = SigmaCoordinate(N, ptop) <: PressureCoordinate{N}\n\nPressure based sigma-coordinate for N levels with top pressure ptop. Pressure levels are linear in vertical coordinate k :     k/N = (ps-p)/(ps-ptop) where k ranges from 0 (ground) to N (model top).\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.SpectralDomain","page":"Home","title":"CFDomains.SpectralDomain","text":"SpectralDomain <: AbstractDomain\n\nparent type of SpectralSphere\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.SpectralSphere","page":"Home","title":"CFDomains.SpectralSphere","text":"Parent type for spherical domains using spherical harmonics.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.VHLayout","page":"Home","title":"CFDomains.VHLayout","text":"struct VHLayout{rank} end\nlayout = VHLayout(rank)\n\nSingleton type describing a multi-layer data layout where vertical columns are contiguous. rank is the number of horizontal indices (1 or 2).\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.VerticalCoordinate","page":"Home","title":"CFDomains.VerticalCoordinate","text":"abstract type VerticalCoordinate{N} end\n\nParent type for generalized vertical coordinates ranging from 0 to N. See also PressureCoordinate.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.allocate_field","page":"Home","title":"CFDomains.allocate_field","text":"field = allocate_field(kind::Symbol, domain::AbstractDomain, precision::Type)\n\nAllocate a field of the given kind and precision over the given domain. Typical values for precision are Float32, Float64 or ForwardDiff.Dual. Depending on the domain, valid values for kind may include :scalar, :vector, :scalar_spec, scalar_spat (spectral/spatial representation of a scalar field), :vector_spec, vector_spat (spectral/spatial representation of a vector field).\n\nInternally, allocate_field(kind::Symbol, domain, F) returns allocate_field(Val(kind), domain, F). To specialize allocate_field for MyDomain <: AbstractDomain, one must provide methods for:\n\nallocate_field(::Val{kind}, domain::MyDomain, F)\n\nwhere symbol kind::Symbol is one of the valid field kinds for that domain.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.allocate_fields","page":"Home","title":"CFDomains.allocate_fields","text":"fields = allocate_fields(kinds::Tuple, domain::AbstractDomain, F::Type)\nfields = allocate_fields(kinds::NamedTuple, domain::AbstractDomain, F::Type)\n\nAllocate a (named) tuple of fields according to the provided kinds. For instance:\n\nfields = allocate_fields((:vector, :scalar), domain, F)\nfields = allocate_fields((a=:vector, b=:scalar), domain, F)\n\nare equivalent to, respectively:\n\nfields = (allocate_field(:vector, domain, F), allocate_field(:scalar, domain, F))\nfields = (a=allocate_field(:vector, domain, F), b=allocate_field(:scalar, domain, F))\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.data_layout-Tuple{CFDomains.Shell}","page":"Home","title":"CFDomains.data_layout","text":"layout = data_layout(shell::Shell)\n\nReturn layout describing the data layout of multi-layer domain shell.\n\nlayout = data_layout(domain::Domain)\n\nReturn layout describing the preferred data layout for a shell made of layers of type Domain.\n\nTypical values for layout are the singletons HVLayout() (layers are contiguous in memory) and VHLayout (columns are contiguous in memory).\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.hyperdiff_shell!","page":"Home","title":"CFDomains.hyperdiff_shell!","text":"new_data = hyperdiff_shell!(layer, layout, filter, out_data, in_data, scratch)\n\nApply hyperdiffusive filtertoindata. The result is written intooutdataand returned. Ifdomain::SpectralDomain, the filter applies to spectral coefficients. Ifout_data::Void, it is adequately allocated. SeeHyperDiffusion.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.hyperdiffusion!-Tuple{CFDomains.Shell, Vararg{Any, 4}}","page":"Home","title":"CFDomains.hyperdiffusion!","text":"new_data = hyperdiffusion!(domain, filter, out_data, in_data, scratch)\n\nApply hyperdiffusive filtertoindata. The result is written intooutdataand returned. Ifdomain::SpectralDomain, the filter applies to spectral coefficients. Ifout_data::Void, it is adequately allocated. SeeHyperDiffusion.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.laplace_dx","page":"Home","title":"CFDomains.laplace_dx","text":"Estimates the largest eigenvalue -lambda=dx^-2 of the scalar Laplace operator and returns dx which is a (non-dimensional) length on the unit sphere characterizing the mesh resolution. By design, the Courant number for the wave equation with unit wave speed solved with time step dt is dt/dx.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.mass_coordinate","page":"Home","title":"CFDomains.mass_coordinate","text":"mcoord = mass_coordinate(pcoord::PressureCoordinate, metric_cov=1)\n\nReturn the mass-based coordinate deduced from pcoord and the covariant metric factor metric_cov. This object mcoord can then be used with:\n\nm = mass_level(k, masstot, vcoord)\n\nWith metric_cov==1, masstot should be in Pa ( kg/m²⋅(m/s²) ). With metric_cov the covariant metric factor, masstot should be in kg⋅(m/s²). See also mass_level.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.mass_coordinate-Tuple{CFDomains.MassCoordinate}","page":"Home","title":"CFDomains.mass_coordinate","text":"mcoord = mass_coordinate(mcoord::MassCoordinate)\n\nReturn mcoord itself, unchanged. Interim function for backwards compatibility.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.mass_level","page":"Home","title":"CFDomains.mass_level","text":"m = mass_level(k, masstot, mcoord::MassCoordinate{N})\n\nReturn mass m in level k/2 as prescribed by vertical coordinate mcoord and total mass masstot.\n\nSo-called full levels correspond to odd values k=1,2...2N-1 while interfaces between full levels (so-called half-levels) correspond to even values k=0,2...2N\n\nmasstot may be:\n\nper unit surface, with unit Pa\nper unit non-dimensional surface (e.g. on the unit sphere), with unit kg.(m/s²))\n\nWhich convention is appropriate depends on the metric_factor provided when constructing mcoord. See also mass_coordinate.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.periodize!-Tuple{Tuple, CFDomains.AbstractDomain, Vararg{Any}}","page":"Home","title":"CFDomains.periodize!","text":"periodize!(data, box::AbstractBox, mgr)\n\nEnforce horizontally-periodic boundary conditions on array data representing grid point values in box. data may also be a collection, in which case periodize! is applied to each element of the collection. Call periodize! on data obtained by computations involving horizontal averaging/differencing.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.pressure_level","page":"Home","title":"CFDomains.pressure_level","text":"p = pressure_level(k, ps, vcoord::PressureCoordinate{N})\n\nReturns pressure p corresponding to level k/2 as prescribed by vertical coordinate vcoord and surface pressure ps.\n\nSo-called full levels correspond to odd values k=1,2...2N-1 while interfaces between full levels (so-called half-levels) correspond to even values k=0,2...2N\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.scratch_hyperdiff-Tuple{Any, Val, Any}","page":"Home","title":"CFDomains.scratch_hyperdiff","text":"scratch = scratch_hyperdiff(domain, Val(fieldtype), field)\n\nReturn scratch space used to apply hyperdiffusion on domain for a field of a certain fieldtype. See HyperDiffusion and hyperdiffusion!.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.scratch_space-Tuple{Any, Any, Any}","page":"Home","title":"CFDomains.scratch_space","text":"scratch = scratch_space(filter::AbstractFilter, field, [scratch])\n\nIf scratch is omitted or ::Void, return scratch space for applying filter to field, allocated by scratch_hyperdiff. Otherwise just return scratch. See also HyperDiffusion.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.shell-Tuple{Any, Any}","page":"Home","title":"CFDomains.shell","text":"multi_layer_domain = shell(nz::Int, layer::AbstractDomain)\n\nReturn a multi-layer domain made of nz layers with data layout specified by data_layout(layer).\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.transpose!-Tuple{MutatingOrNot.Void, Any, Any}","page":"Home","title":"CFDomains.transpose!","text":"x_ji = transpose!(x_ji, mgr, x_ij)\ny_ji = transpose!(void, mgr, y_ij)\n\nTransposes x_ij and writes the result into x_ji, which may be ::Void, in which case it is allocated.\n\nWhen working with shells it is sometimes useful to transpose fields for performance. CFDomains.transpose! can be specialized for specific managers, for instance:\n\nimport CFDomains: transpose!, Void\nusing Strided: @strided\nfunction transpose!(x, ::MultiThread, y)\n   @strided permutedims!(x, y, (2,1))\n   return x # otherwise returns a StridedView\nend\ntranspose!(::Void, ::MultiThread, y) = permutedims(y, (2,1)) # for non-ambiguity\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.VerticalInterpolation.interpolate!","page":"Home","title":"CFDomains.VerticalInterpolation.interpolate!","text":"interpolated = interpolate!(mgr::LoopManager, domain::Shell, field, coord, refs, increasing)\n\nInterpolate field defined on 3D domain to reference values refs of coord. If coord increases with level number, increasing==true and vice-versa. refs must be sorted according to increasing. out may be void. Example:\n\nT_ref = interpolate!(mgr, void, domain, [850., 500.], temperature, pressure, false)\n\nWith these arguments, interpolate! is not meant to be specialized for a specific domain type. Instead, specialize:     interpolated = interpolate!(mgr, out, layout::Layout, refs, field, coord, increasing::Val)\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.Stencils.Fix","page":"Home","title":"CFDomains.Stencils.Fix","text":"g = Fix(f, args)\n\nReturn callable g such that g(x,...) calls f by prepending args... before x...:\n\ng(x...) == f(args..., x...)\n\nThis is similar to Base.Fix1, with several arguments.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.Stencils.TRiSK-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.TRiSK","text":"vsphere = TRiSK(vsphere) # optional, returns only relevant fields as a named tuple\ntrisk = TRiSK(vsphere, edge, Val(N))\nU_perp[edge]    = trisk(U)        # linear, single-layer, U::AbstractVector\nU_perp[k, edge] = trisk(U, k)     # linear, multi-layer, U::AbstractMatrix\nqU[edge]        = trisk(U, q)     # nonlinear, single-layer\nqU[k, edge]     = trisk(U, q, k)  # nonlinear, multi-layer\n\nCompute TRiSK operator U⟂ or q×U at edge::Int of vsphere::VoronoiSphere.\n\nU is a contravariant vector field known at edges. U_perp is a covariant vector field known at edges.\n\nN=sphere.trisk_deg[edge] is the number of edges involved in the TRiSK stencil and must be provided as a compile-time constant for performance.  This may be done via the macro @unroll from ManagedLoops.\n\n@inbounds propagates into TRiSK and trisk.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.average_ie-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.average_ie","text":"vsphere = average_ie(vsphere) # optional, returns only relevant fields as a named tuple\navg = average_ie(vsphere, edge)\nqe[edge] = avg(qi)         # single-layer, qi::AbstractVector\nqe[k, edge] = avg(qi, k)   # multi-layer, qi::AbstractMatrix\n\nInterpolate scalar field at edge::Int of vsphere::VoronoiSphere by a centered average (second-order accurate).\n\nqi is a scalar field known at primal cells. qe is a scalar field known at edges.\n\n@inbounds propagates into average_ie and avg.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.average_iv-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.average_iv","text":"vsphere = average_iv(vsphere) # optional, returns only relevant fields as a named tuple\navg = average_iv(vsphere, dual_cell)\nqv[dual_cell] = avg(qi)         # single-layer, qi::AbstractVector\nqv[k, dual_cell] = avg(qi, k)   # multi-layer, qi::AbstractMatrix\n\nInterpolate scalar field at dual_cell::Int of vsphere::VoronoiSphere by an area-weighted average (first-order accurate).\n\nqi is a scalar field known at primal cells. qv is a scalar field known at dual cells.\n\n@inbounds propagates into average_iv and avg.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.average_ve-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.average_ve","text":"vsphere = average_ve(vsphere) # optional, returns only relevant fields as a named tuple\navg = average_ve(vsphere, edge)\nqe[edge] = avg(qv)         # single-layer, qv::AbstractVector\nqe[k, edge] = avg(qv, k)   # multi-layer, qv::AbstractMatrix\n\nInterpolate scalar field at edge::Int of vsphere::VoronoiSphere by a centered average (first-order accurate).\n\nqv is a scalar field known at dual cells. qe is a scalar field known at edges.\n\n@inbounds propagates into average_ve and avg.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.centered_flux-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.centered_flux","text":"vsphere = centered_flux(vsphere) # optional, returns only relevant fields as a named tuple\ncflux = centered_flux(vsphere, edge)\nflux[edge] = cflux(mass, ucov)         # single-layer, ucov::AbstractVector\nflux[k, edge] = cflux(mass, ucov, k)   # multi-layer, ucov::AbstractMatrix\n\nCompute centered flux at edge::Int of vsphere::VoronoiSphere, with respect to the unit sphere. \n\nmass is a scalar field known at primal cells. ucov is a covariant vector field known at edges. flux is a contravariant vector field known at edges. \n\nIf ucov is  defined with respect to a physical metric (e.g. in m²⋅s⁻¹)  which is conformal, multiply cflux by the contravariant physical  metric factor (in m⁻²). mass being e.g. in kg, on gets a flux  in kg⋅s⁻¹ which can be fed into divergence.\n\n@inbounds propagates into centered_flux and cflux.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.contraction-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.contraction","text":"vsphere = contraction(vsphere::VoronoiSphere) # optional, returns only relevant fields as a named tuple\ncontract = contraction(vsphere, cell::Int, v::Val{N})\n\n# single-layer, `ucontra` and `vcov` are ::AbstractVector\nuv[cell] = contract(ucontra, vcov) \n\n# multi-layer, `ucontra` and `vcov` are ::AbstractMatrix\nuv[k, cell] = contract(ucontra, vcov, k)\n\nCompute the contraction of ucov and vcov at cell::Int of vsphere::VoronoiSphere.  ucontra is a contravariant vector field known at edges. vcov is a covariant vector field known at edges.\n\nN=sphere.primal_deg[cell] is the number of cell edges and must be provided as a compile-time constant for performance. This may be done via the macro @unroll from ManagedLoops. \n\n@inbounds propagates into contraction and contract.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.curl-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.curl","text":"vsphere = curl(vsphere) # optional, returns only relevant fields as a named tuple\nop = curl(vsphere, dual_cell)\ncurlu[dual_cell] = op(ucov)         # single-layer, ucov::AbstractVector\ncurlu[k, dual_cell] = op(ucov, k)   # multi-layer, ucov::AbstractMatrix\n\nCompute curl of ucov at dual_cell::Int of vsphere::VoronoiSphere.  ucov is a covariant vector field known at edges. curlu is a density (two-form) over dual cells. To obtain a scalar, divide curlu by the dual cell area vsphere.Av\n\n@inbounds propagates into curl and op.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.div_form-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.div_form","text":"vsphere = div_form(vsphere) # optional, returns only relevant fields as a named tuple\ndivf = div_form(vsphere, cell, Val(N))\ndvg[cell] = divf(flux) # single-layer, flux::AbstractVector\ndvg[k, cell] = divf(flux, k)  # multi-layer, flux::AbstractMatrix\n\nCompute divergence with respect to the unit sphere of flux at cell::Int of vsphere::VoronoiSphere. flux is a contravariant vector field known at edges. dvg is a density (two-form) over primal cells. To obtain a scalar, divide dvg by the primal cell area vsphere.Ai\n\nN=sphere.primal_deg[cell] is the number of cell edges and must be provided as a compile-time constant for performance. This may be done via the macro @unroll from ManagedLoops. \n\n@inbounds propagates into div_form and divf.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.divergence-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.divergence","text":"vsphere = divergence(vsphere) # optional, returns only relevant fields as a named tuple\ndiv = divergence(vsphere, cell, Val(N))\ndvg[cell] = div(flux) # single-layer, flux::AbstractVector\ndvg[k, cell] = div(flux, k)  # multi-layer, flux::AbstractMatrix\n\nCompute divergence with respect to the unit sphere of flux at cell::Int of vsphere::VoronoiSphere. flux is a contravariant vector field known at edges. dvg is a scalar field known at primal cells.\n\nN=sphere.primal_deg[cell] is the number of cell edges and must be provided as a compile-time constant for performance. This may be done via the macro @unroll from ManagedLoops. \n\n@inbounds propagates into divergence and div.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.dot_prod_contra-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.dot_prod_contra","text":"vsphere = dot_prod_contra(vsphere::VoronoiSphere) # optional, returns only relevant fields as a named tuple\ndot_prod = dot_prod_contra(vsphere, cell::Int, v::Val{N})\n\n# single-layer, `U` and `V` are ::AbstractVector\ndp[cell] = dot_prod(U, V) \n\n# multi-layer, `U` and `V` are ::AbstractMatrix\ndp[k, cell] = dot_prod(U, V, k)\n\nCompute dot product with respect to the unit sphere of U, V at cell::Int of vsphere::VoronoiSphere.  U and V are contravariant vector fields known at edges.\n\nN=sphere.primal_deg[cell] is the number of cell edges and must be provided as a compile-time constant for performance. This may be done via the macro @unroll from ManagedLoops. \n\n@inbounds propagates into dot_prod_contra and dot_prod.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.dot_product-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.dot_product","text":"vsphere = dot_product(vsphere::VoronoiSphere) # optional, returns only relevant fields as a named tuple\ndot_prod = dot_product(vsphere, cell::Int, v::Val{N})\n\n# single-layer, `ucov` and `vcov` are ::AbstractVector\ndp[cell] = dot_prod(ucov, vcov) \n\n# multi-layer, `ucov` and `vcov` are ::AbstractMatrix\ndp[k, cell] = dot_prod(ucov, vcov, k)\n\nCompute dot product with respect to the unit sphere of ucov, vcov at cell::Int of vsphere::VoronoiSphere.  ucov and vcov are covariant vector fields known at edges.\n\nN=sphere.primal_deg[cell] is the number of cell edges and must be provided as a compile-time constant for performance. This may be done via the macro @unroll from ManagedLoops. \n\n@inbounds propagates into dot_product and dot_prod.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.grad_form-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.grad_form","text":"vsphere = grad_form(vsphere) # optional, returns only relevant fields as a named tuple\ngrad = grad_form(vsphere, edge)\ngradcov[edge] = grad(Q)         # single-layer, Q::AbstractVector\ngradcov[k, edge] = grad(Q, k)   # multi-layer, Q::AbstractMatrix\n\nCompute gradient of Q at edge::Int of vsphere::VoronoiSphere.\n\nQ is a density (two-form) over primal cells. To obtain a scalar, divide Q by the primal cell area vsphere.Ai gradcov is a covariant vector field known at edges. gradcov is numerically zero-curl.\n\n@inbounds propagates into grad_form and gradcov.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.gradient-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.gradient","text":"vsphere = gradient(vsphere) # optional, returns only relevant fields as a named tuple\ngrad = gradient(vsphere, edge)\ngradcov[edge] = grad(q)         # single-layer, q::AbstractVector\ngradcov[k, edge] = grad(q, k)   # multi-layer, q::AbstractMatrix\n\nCompute gradient of q at edge::Int of vsphere::VoronoiSphere.\n\nq is a scalar field known at primal cells. gradcov is a covariant vector field known at edges. gradcov is numerically zero-curl.\n\n@inbounds propagates into gradient and gradcov.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.gradient3d-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.gradient3d","text":"vsphere = gradient3d(vsphere) # optional, returns only relevant fields as a named tuple\ngrad = gradient3d(vsphere, cell, Val(N))\ngradq[ij] = grad(q)         # single-layer, q::AbstractVector\ngradq[k, ij] = grad(q, k)   # multi-layer, q::AbstractMatrix\n\nCompute 3D gradient of q at cell::Int of vsphere::VoronoiSphere. q is a scalar field known at primal cells. gradq is a 3D vector field yielding a 3-uple at each primal cell.\n\nN=sphere.primal_deg[cell] is the number of cell edges and must be provided as a compile-time constant for performance. This may be done via the macro @unroll from ManagedLoops. \n\n@inbounds propagates into gradient3d and grad.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.gradperp-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.gradperp","text":"vsphere = gradperp(vsphere) # optional, returns only relevant fields as a named tuple\ngrad = gradperp(vsphere, edge)\nflux[edge] = grad(psi)         # single-layer, q::AbstractVector\nflux[k, edge] = grad(psi, k)   # multi-layer, q::AbstractMatrix\n\nCompute grad⟂ of streamfunction psi at edge::Int of vsphere::VoronoiSphere.\n\npsi is a scalar field known at dual cells. flux is a contravariant vector field known at edges. flux is numerically non-divergent.\n\n@inbounds propagates into gradperp and grad.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.Stencils.perp-Tuple{Any}","page":"Home","title":"CFDomains.Stencils.perp","text":"op = perp(vsphere) # optional, returns only relevant fields as a named tuple\nop = perp(vsphere, ij)\nU_perp[ij] = op(U)              # single-layer, U::AbstractVector\nU_perp[k, ij] = op(U, k::Int)   # multi-layer, U::AbstractMatrix\n\nCompute the perp operator U⟂ at edge::Int of vsphere::VoronoiSphere. Unlike the TRiSK operator, this operator is not antisymmetric but it has a smaller stencil and is numerically consistent.\n\nArray U represents a vector field U by its  components normal to edges of primal cells. U_perp represents similarly U⟂. Equivalently, it represents U   by its components normal to edges of dual cells.\n\n@inbounds propagates into perp and op.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.VoronoiOperators.AsDensity-Tuple{Any}","page":"Home","title":"CFDomains.VoronoiOperators.AsDensity","text":"as_density = AsDensity(vsphere) # a `LazyDiagonalOp`\ndensity = as_density(scalar)    # a `WritableDVP` (diagonal-vector-product)\nop!(density, ...)               # pass `density as *output* argument\n\nGiven a zero-form scalar, as_density returns the equivalent two-form as a lazy, write-only AbstractArray to be passed to a VoronoiOperator op!  as an output argument.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.VoronoiOperators.pdv","page":"Home","title":"CFDomains.VoronoiOperators.pdv","text":"fa = pdv(fun, a)\nfa, fb = pdv(fun, a, b)\nfa, fb, fc = pdv(fun, a, b, c)\n\nReturn the partial derivatives of scalar function fun evaluated at input a, .... This function is implemented only when the package ForwardDiff is loaded either directly from the main program or via some dependency.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.ZeroArrays.zero_array-Tuple{AbstractArray}","page":"Home","title":"CFDomains.ZeroArrays.zero_array","text":"z = zero_array(a::AbstractArray)\n\nReturn z which behaves like a read-only array with the same axes as a, filled with zeros.\n\nz[i...] does not check bounds and always returns the special value Zero(),  which behaves like 0 when passed to +, * and muladd. \n\n\n\n\n\n","category":"method"}]
}
