var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CFDomains","category":"page"},{"location":"#CFDomains","page":"Home","title":"CFDomains","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CFDomains.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CFDomains, CFDomains.VerticalInterpolation]","category":"page"},{"location":"#CFDomains.AbstractDomain","page":"Home","title":"CFDomains.AbstractDomain","text":"Parent type of SpectralDomain and FDDomain\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.FDDomain","page":"Home","title":"CFDomains.FDDomain","text":"FDDomain <: AbstractDomain`\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.HVLayout","page":"Home","title":"CFDomains.HVLayout","text":"struct HVLayout{rank} end\nlayout = HVLayout(rank)\n\nSingleton type describing a multi-layer data layout where horizontal layers are contiguous in memory. rank is the number of horizontal indices (1 or 2).\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.HyperDiffusion-Union{Tuple{F}, Tuple{D}, Tuple{D, Any, F, Any}} where {D, F}","page":"Home","title":"CFDomains.HyperDiffusion","text":"filter = HyperDiffusion(fieldtype::Symbol, domain, niter::Int, nu)                  # user-friendly\nfilter = HyperDiffusion{fieldtype, D, F, X}(domain::D, niter::Int, nu::F, extra::X) # internal\n\nReturn a filter that applies Laplacian diffusion iterated niter times with hyperdiffusive coefficient nu â‰¥ 0 on fields of type fieldtype. Supported field types are :scalar, :vector, :vector_curl, :vector_div.\n\nThe filter is to be used as:\n\n# out-of-place, allocates `scratch`, allocates and returns `filtered_data`\nfiltered_data = filter(void, in_data, void)\n\n# mutating, non-allocating\nout_data = filter(out_data, in_data, scratch)\n\n# in-place, non-allocating\ninout_data = filter(inout_data, inout_data, scratch)\n\nfilter(out_data, in_data, scratch) returns hyperdiffusion!(filter.domain, filter, out_data, in_data, scratch). If scratch::Void, then\n\nscratch = scratch_space(filter, in_data)\n\nThe user-friendly HyperDiffusion may be specialized for specific types of domain. The specialized method should call the internal constructor which takes an extra argument extra, stored as filter.extra for later use by hyperdiffusion!. The default user-friendly constructor sets extra=nothing.\n\nSimilarly, scratch_space(filter, in_data) calls scratch_hyperdiff(f.domain, Val(fieldtype), in_data) which by default returns nothing. scratch_hyperdiff may be specialized for specific domain types and fieldtype.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.PressureCoordinate","page":"Home","title":"CFDomains.PressureCoordinate","text":"abstract type PressureCoordinate{N} <: VerticalCoordinate{N} end\n\nParent type for a pressure-based vertical coordinate. Children types should specialize pressure_level and mass_level. See also VerticalCoordinate.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.Shell","page":"Home","title":"CFDomains.Shell","text":"multi_layer_domain = Shell(nz::Int, layer::AbstractDomain, layout)\n\nReturn a multi-layer domain made of nz layers with data layout specified by layout. Unless you know what you are doing, it is recommended to use rather:\n\nmulti_layer_domain = shell(nz::Int, layer::AbstractDomain)\n\nwhich gets the data layout from data_layout(layer). Otherwise, multi_layer_domain may be non-optimal or non-usable.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.SigmaCoordinate","page":"Home","title":"CFDomains.SigmaCoordinate","text":"sigma = SigmaCoordinate(N, ptop) <: PressureCoordinate{N}\n\nPressure based sigma-coordinate for N levels with top pressure ptop. Pressure levels are linear in vertical coordinate k :     k/N = (ps-p)/(ps-ptop) where k ranges from 0 (ground) to N (model top).\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.SpectralDomain","page":"Home","title":"CFDomains.SpectralDomain","text":"SpectralDomain <: AbstractDomain\n\nparent type of SpectralSphere\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.SpectralSphere","page":"Home","title":"CFDomains.SpectralSphere","text":"Parent type for spherical domains using spherical harmonics.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.VHLayout","page":"Home","title":"CFDomains.VHLayout","text":"struct VHLayout{rank} end\nlayout = VHLayout(rank)\n\nSingleton type describing a multi-layer data layout where vertical columns are contiguous. rank is the number of horizontal indices (1 or 2).\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.VerticalCoordinate","page":"Home","title":"CFDomains.VerticalCoordinate","text":"abstract type VerticalCoordinate{N} end\n\nParent type for generalized vertical coordinates ranging from 0 to N. See also PressureCoordinate.\n\n\n\n\n\n","category":"type"},{"location":"#CFDomains.allocate_field","page":"Home","title":"CFDomains.allocate_field","text":"field = allocate_field(kind::Symbol, domain::AbstractDomain, precision::Type)\n\nAllocate a field of the given kind and precision over the given domain. Typical values for precision are Float32, Float64 or ForwardDiff.Dual. Depending on the domain, valid values for kind may include :scalar, :vector, :scalar_spec, scalar_spat (spectral/spatial representation of a scalar field), :vector_spec, vector_spat (spectral/spatial representation of a vector field).\n\nInternally, allocate_field(kind::Symbol, domain, F) returns allocate_field(Val(kind), domain, F). To specialize allocate_field for MyDomain <: AbstractDomain, one must provide methods for:\n\nallocate_field(::Val{kind}, domain::MyDomain, F)\n\nwhere symbol kind::Symbol is one of the valid field kinds for that domain.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.allocate_fields","page":"Home","title":"CFDomains.allocate_fields","text":"fields = allocate_fields(kinds::Tuple, domain::AbstractDomain, F::Type)\nfields = allocate_fields(kinds::NamedTuple, domain::AbstractDomain, F::Type)\n\nAllocate a (named) tuple of fields according to the provided kinds. For instance:\n\nfields = allocate_fields((:vector, :scalar), domain, F)\nfields = allocate_fields((a=:vector, b=:scalar), domain, F)\n\nare equivalent to, respectively:\n\nfields = (allocate_field(:vector, domain, F), allocate_field(:scalar, domain, F))\nfields = (a=allocate_field(:vector, domain, F), b=allocate_field(:scalar, domain, F))\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.data_layout-Tuple{CFDomains.Shell}","page":"Home","title":"CFDomains.data_layout","text":"layout = data_layout(shell::Shell)\n\nReturn layout describing the data layout of multi-layer domain shell.\n\nlayout = data_layout(domain::Domain)\n\nReturn layout describing the preferred data layout for a shell made of layers of type Domain.\n\nTypical values for layout are the singletons HVLayout() (layers are contiguous in memory) and VHLayout (columns are contiguous in memory).\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.hyperdiff_shell!","page":"Home","title":"CFDomains.hyperdiff_shell!","text":"new_data = hyperdiff_shell!(layer, layout, filter, out_data, in_data, scratch)\n\nApply hyperdiffusive filtertoindata. The result is written intooutdataand returned. Ifdomain::SpectralDomain, the filter applies to spectral coefficients. Ifout_data::Void, it is adequately allocated. SeeHyperDiffusion.\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.hyperdiffusion!-Tuple{CFDomains.Shell, Vararg{Any, 4}}","page":"Home","title":"CFDomains.hyperdiffusion!","text":"new_data = hyperdiffusion!(domain, filter, out_data, in_data, scratch)\n\nApply hyperdiffusive filtertoindata. The result is written intooutdataand returned. Ifdomain::SpectralDomain, the filter applies to spectral coefficients. Ifout_data::Void, it is adequately allocated. SeeHyperDiffusion.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.laplace_dx-Tuple{CFDomains.VoronoiSphere}","page":"Home","title":"CFDomains.laplace_dx","text":"Estimates the largest eigenvalue -lambda=dx^-2 of the scalar Laplace operator and returns dx which is a (non-dimensional) length on the unit sphere characterizing the mesh resolution. By design, the Courant number for the wave equation with unit wave speed solved with time step dt is dt/dx.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.mass_level","page":"Home","title":"CFDomains.mass_level","text":"m = mass_level(k, masstot, vcoord::PressureCoordinate{N})\n\nReturn mass m in level k/2 as prescribed by vertical coordinate vcoord and total mass masstot, i.e. surface pressure minus top pressure.\n\nSo-called full levels correspond to odd values k=1,2...2N-1 while interfaces between full levels (so-called half-levels) correspond to even values k=0,2...2N\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.periodize!-Tuple{Tuple, CFDomains.AbstractDomain, Vararg{Any}}","page":"Home","title":"CFDomains.periodize!","text":"periodize!(data, box::AbstractBox, mgr)\n\nEnforce horizontally-periodic boundary conditions on array data representing grid point values in box. data may also be a collection, in which case periodize! is applied to each element of the collection. Call periodize! on data obtained by computations involving horizontal averaging/differencing.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.pressure_level","page":"Home","title":"CFDomains.pressure_level","text":"p = pressure_level(k, ps, vcoord::PressureCoordinate{N})\n\nReturns pressure p corresponding to level k/2 as prescribed by vertical coordinate vcoord and surface pressure ps.\n\nSo-called full levels correspond to odd values k=1,2...2N-1 while interfaces between full levels (so-called half-levels) correspond to even values k=0,2...2N\n\n\n\n\n\n","category":"function"},{"location":"#CFDomains.scratch_hyperdiff-Tuple{Any, Val, Any}","page":"Home","title":"CFDomains.scratch_hyperdiff","text":"scratch = scratch_hyperdiff(domain, Val(fieldtype), field)\n\nReturn scratch space used to apply hyperdiffusion on domain for a field of a certain fieldtype. See HyperDiffusion and hyperdiffusion!.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.scratch_space-Tuple{Any, Any, Any}","page":"Home","title":"CFDomains.scratch_space","text":"scratch = scratch_space(filter::AbstractFilter, field, [scratch])\n\nIf scratch is omitted or ::Void, return scratch space for applying filter to field, allocated by scratch_hyperdiff. Otherwise just return scratch. See also HyperDiffusion.\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.shell-Tuple{Any, Any}","page":"Home","title":"CFDomains.shell","text":"multi_layer_domain = shell(nz::Int, layer::AbstractDomain)\n\nReturn a multi-layer domain made of nz layers with data layout specified by data_layout(layer).\n\n\n\n\n\n","category":"method"},{"location":"#CFDomains.VerticalInterpolation.interpolate!","page":"Home","title":"CFDomains.VerticalInterpolation.interpolate!","text":"interpolated = interpolate!(mgr::LoopManager, domain::Shell, field, coord, refs, increasing)\n\nInterpolate field defined on 3D domain to reference values refs of coord. If coord increases with level number, increasing==true and vice-versa. refs must be sorted according to increasing. out may be void. Example:\n\nT_ref = interpolate!(mgr, void, domain, [850., 500.], temperature, pressure, false)\n\nWith these arguments, interpolate! is not meant to be specialized for a specific domain type. Instead, specialize:     interpolated = interpolate!(mgr, out, layout::Layout, refs, field, coord, increasing::Val)\n\n\n\n\n\n","category":"function"}]
}
